üîê PATCH 1.6.18 ‚Äî Recipe Cost Guardrails & Canonical Views
‚úÖ ASSUMPTIONS (matches your system)
PostgreSQL
Prisma ORM
Tables already exist:
ingredients
recipe_ingredients
recipes
1Ô∏è‚É£ DATABASE MIGRATION (SAFE, NON-DESTRUCTIVE)
Create file:
prisma/migrations/20260103_recipe_cost_guardrails/migration.sql
Copy code
Sql
-- ===============================
-- PATCH 1.6.18 ‚Äî COST GUARDRAILS
-- ===============================

-- 1. HARD CONSTRAINTS (prevent future corruption)
ALTER TABLE ingredients
  ADD CONSTRAINT chk_purchase_unit_qty_positive
  CHECK (purchase_unit_qty > 0);

ALTER TABLE ingredients
  ADD CONSTRAINT chk_unit_cost_non_negative
  CHECK (unit_cost >= 0);

-- 2. CANONICAL RECIPE COST VIEW
-- This is THE source of truth for recipe food cost
CREATE OR REPLACE VIEW v_recipe_cost AS
SELECT
  r.id                     AS recipe_id,
  r.name                   AS recipe_name,
  ROUND(SUM(
    (i.unit_cost / i.purchase_unit_qty) * ri.portion_qty
  ), 2)                     AS food_cost
FROM recipes r
JOIN recipe_ingredients ri ON ri.recipe_id = r.id
JOIN ingredients i         ON i.id = ri.ingredient_id
GROUP BY r.id, r.name;

-- 3. RECIPE COST BREAKDOWN VIEW (debugging & audits)
CREATE OR REPLACE VIEW v_recipe_cost_lines AS
SELECT
  r.id           AS recipe_id,
  r.name         AS recipe_name,
  i.id           AS ingredient_id,
  i.name         AS ingredient_name,
  ri.portion_qty,
  i.unit_cost,
  i.purchase_unit_qty,
  ROUND(
    (i.unit_cost / i.purchase_unit_qty),
    4
  )              AS cost_per_unit,
  ROUND(
    (i.unit_cost / i.purchase_unit_qty) * ri.portion_qty,
    2
  )              AS line_cost
FROM recipes r
JOIN recipe_ingredients ri ON ri.recipe_id = r.id
JOIN ingredients i         ON i.id = ri.ingredient_id;

-- 4. SANITY VIEW ‚Äî FLAGS PROBLEM DATA
CREATE OR REPLACE VIEW v_recipe_cost_flags AS
SELECT
  recipe_id,
  recipe_name,
  ingredient_name,
  portion_qty,
  unit_cost,
  purchase_unit_qty,
  CASE
    WHEN purchase_unit_qty <= 0 THEN 'INVALID_PURCHASE_UNIT_QTY'
    WHEN unit_cost / purchase_unit_qty > 50 THEN 'SUSPICIOUS_COST_PER_UNIT'
    WHEN portion_qty > purchase_unit_qty THEN 'PORTION_EXCEEDS_PACK'
    ELSE NULL
  END AS issue
FROM v_recipe_cost_lines
WHERE
  purchase_unit_qty <= 0
  OR unit_cost / purchase_unit_qty > 50
  OR portion_qty > purchase_unit_qty;
‚úÖ This does not touch existing tables or data
‚úÖ Safe to run in production
‚úÖ Immediately fixes future corruption
2Ô∏è‚É£ PRISMA READ-ONLY MODELS (NO WRITES)
Edit: prisma/schema.prisma
Copy code
Prisma
/// ===============================
/// PATCH 1.6.18 ‚Äî READ ONLY VIEWS
/// ===============================

model VRecipeCost {
  recipe_id   String  @id
  recipe_name String
  food_cost   Decimal

  @@map("v_recipe_cost")
}

model VRecipeCostLine {
  recipe_id          String
  recipe_name        String
  ingredient_id      String
  ingredient_name    String
  portion_qty        Decimal
  unit_cost          Decimal
  purchase_unit_qty  Decimal
  cost_per_unit      Decimal
  line_cost          Decimal

  @@map("v_recipe_cost_lines")
  @@ignore
}

model VRecipeCostFlag {
  recipe_id        String
  recipe_name      String
  ingredient_name  String
  portion_qty      Decimal
  unit_cost        Decimal
  purchase_unit_qty Decimal
  issue            String?

  @@map("v_recipe_cost_flags")
  @@ignore
}
‚ö†Ô∏è Views are read-only by design
‚ö†Ô∏è No agent can accidentally write to them
3Ô∏è‚É£ SERVICE: CANONICAL COST ACCESS
Create file:
server/services/recipeCost.service.ts
Copy code
Ts
import { prisma } from "@/server/db";

export async function getAllRecipeCosts() {
  return prisma.$queryRawUnsafe(`
    SELECT * FROM v_recipe_cost
    ORDER BY food_cost DESC
  `);
}

export async function getRecipeCostBreakdown(recipeId: string) {
  return prisma.$queryRawUnsafe(`
    SELECT *
    FROM v_recipe_cost_lines
    WHERE recipe_id = $1
    ORDER BY line_cost DESC
  `, recipeId);
}

export async function getRecipeCostFlags() {
  return prisma.$queryRawUnsafe(`
    SELECT *
    FROM v_recipe_cost_flags
    ORDER BY recipe_name
  `);
}
4Ô∏è‚É£ OPTIONAL (BUT HIGHLY RECOMMENDED) ‚Äî INGREDIENT SAVE GUARD
Wherever ingredients are created/edited, add this before save:
Copy code
Ts
if (!purchase_unit_qty || purchase_unit_qty <= 0) {
  throw new Error("purchase_unit_qty must be greater than zero");
}

if (unit_cost < 0) {
  throw new Error("unit_cost cannot be negative");
}
This prevents any future silent corruption.
‚úÖ WHAT THIS PATCH GUARANTEES
‚ùå No more ‚Äúwhole pack per portion‚Äù math bugs
‚úÖ Every recipe has a single authoritative food cost
üîé Any bad data is instantly visible
üîê Safe for agents, safe for production
üìä Ready for receipt ‚Üí ingredient usage next