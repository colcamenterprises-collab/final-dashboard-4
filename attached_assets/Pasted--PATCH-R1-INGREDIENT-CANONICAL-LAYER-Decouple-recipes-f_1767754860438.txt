üîê PATCH R1 ‚Äî INGREDIENT CANONICAL LAYER
Decouple recipes from purchasing (PERMANENT FIX)
‚ö†Ô∏è AGENT RULES
‚ùå DO NOT calculate recipe costs from purchasing items
‚ùå DO NOT use purchase_unit_qty in recipes
‚ùå DO NOT allow ‚Äúservings‚Äù in recipes
‚úÖ Recipes calculate ONLY from ingredients
‚úÖ Purchasing feeds ingredients ONE-WAY
1Ô∏è‚É£ DATABASE ‚Äî INGREDIENTS (CANONICAL)
File: shared/schema.ts
üëâ ADD TABLE
Copy code
Ts
import { pgTable, uuid, text, numeric } from "drizzle-orm/pg-core";

export const ingredient = pgTable("ingredient", {
  id: uuid("id").defaultRandom().primaryKey(),

  name: text("name").notNull(),

  baseUnit: text("base_unit").notNull(), // grams | ml | each
  unitCost: numeric("unit_cost", { precision: 10, scale: 4 }).notNull(), 
  // cost PER baseUnit

  sourcePurchasingItemId: uuid("source_purchasing_item_id"),

  updatedAt: text("updated_at").defaultNow(),
});
2Ô∏è‚É£ ONE-WAY SYNC ‚Äî PURCHASING ‚Üí INGREDIENT
File: server/services/ingredientSync.service.ts
üëâ CREATE FILE
Copy code
Ts
import { db } from "@/db";
import { ingredient } from "@/shared/schema";
import { purchasingItem } from "@/shared/schema";
import { eq } from "drizzle-orm";

function deriveUnitCost(
  unitCost: number,
  purchaseQty: number,
  purchaseUnit: string
) {
  if (purchaseUnit === "kg") return unitCost / (purchaseQty * 1000);
  if (purchaseUnit === "l") return unitCost / (purchaseQty * 1000);
  return unitCost / purchaseQty; // grams / ml / each
}

export async function syncIngredientFromPurchasing(purchasingItemId: string) {
  const item = await db
    .select()
    .from(purchasingItem)
    .where(eq(purchasingItem.id, purchasingItemId))
    .then((r) => r[0]);

  if (!item) throw new Error("Purchasing item not found");

  const baseUnit =
    item.purchaseUnit === "kg"
      ? "grams"
      : item.purchaseUnit === "l"
      ? "ml"
      : item.purchaseUnit;

  const costPerBaseUnit = deriveUnitCost(
    Number(item.unitCost),
    Number(item.purchaseUnitQty),
    item.purchaseUnit
  );

  await db.insert(ingredient).values({
    name: item.name,
    baseUnit,
    unitCost: costPerBaseUnit,
    sourcePurchasingItemId: item.id,
  });
}
3Ô∏è‚É£ RECIPE INGREDIENTS ‚Äî REWIRE TO INGREDIENTS
File: shared/schema.ts
üëâ MODIFY EXISTING recipe_ingredient
Copy code
Ts
ingredientId: uuid("ingredient_id").notNull(),
portionQty: numeric("portion_qty", { precision: 10, scale: 4 }).notNull(),
‚ùå REMOVE:
purchasing_item_id
portion_unit
ANY purchase references
4Ô∏è‚É£ RECIPE COST ‚Äî FINAL LOGIC (NO CONVERSIONS)
File: server/services/recipeCost.service.ts
üëâ REPLACE ENTIRE INGREDIENT COST BLOCK
Copy code
Ts
const ingredientCost =
  Number(ingredient.unitCost) * Number(recipeIngredient.portionQty);

if (ingredientCost < 0 || !Number.isFinite(ingredientCost)) {
  throw new Error("Invalid ingredient cost calculation");
}
That‚Äôs it.
No unit checks. No conversions. No guessing.
5Ô∏è‚É£ UI ‚Äî RECIPE INGREDIENT INPUT (SIMPLIFY)
File: client/src/components/recipes/RecipeEditModal.tsx
üëâ CHANGE INPUT MODEL
Portion unit dropdown ‚ùå REMOVE
Portion qty = always base unit
Display base unit read-only
Copy code
Tsx
<div className="text-xs text-gray-500">
  Base unit: {ingredient.baseUnit}
</div>
6Ô∏è‚É£ DATA MIGRATION (ONE-TIME)
Manual step (REQUIRED)
For each existing recipe ingredient:
Find linked purchasing item
Create ingredient via sync
Replace purchasing_item_id ‚Üí ingredient_id
Keep portionQty numeric only
This is mechanical and safe.
7Ô∏è‚É£ HARD BLOCKERS (ENFORCED)
‚ùå Recipes cannot reference purchasing
‚ùå ‚Äúserving‚Äù unit eliminated from recipes
‚ùå Runtime conversions removed
‚úÖ Ingredient cost = unitCost √ó qty
‚úÖ REQUIRED RETEST (NON-NEGOTIABLE)
Bacon Scrap
Ingredient unit cost = ‡∏ø0.35 / gram
20 ‚Üí ‡∏ø7.00
Crispy Onions
500g @ ‡∏ø79 ‚Üí ‡∏ø0.158/g
20 ‚Üí ‡∏ø3.16
Cheese Sauce
Must be defined in grams OR ml only
If any number deviates ‚Üí stop.