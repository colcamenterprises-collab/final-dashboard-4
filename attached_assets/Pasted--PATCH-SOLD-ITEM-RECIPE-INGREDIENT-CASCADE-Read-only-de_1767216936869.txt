üîê PATCH ‚Äî SOLD ITEM ‚Üí RECIPE ‚Üí INGREDIENT CASCADE
(Read-only derivation, zero UI changes)
üéØ OBJECTIVE (NON-NEGOTIABLE)
For every POS receipt item:
Resolve ‚Üí Recipe
Expand ‚Üí Recipe Ingredients
If ingredient is a PREP recipe ‚Üí explode again
Store atomic ingredient usage per shift
This enables:
True COGS
Sauce + prep burn-down
Theft / over-portion detection
Purchasing sanity checks
üß± SCOPE (STRICT)
‚úÖ ADD new derived tables
‚úÖ ADD resolver service
‚ùå NO UI changes
‚ùå NO edits to POS ingestion
‚ùå NO edits to recipes or ingredients
‚ùå NO deletes
1Ô∏è‚É£ DATABASE ‚Äî NEW DERIVED TABLES
üìÑ prisma/schema.prisma
ADD ONLY ‚Äî do not touch existing models
Copy code
Prisma
model SoldItemRecipe {
  id         String   @id @default(uuid())
  soldItemId String   @index
  recipeId   String   @index
  quantity   Int
  createdAt DateTime @default(now())
}

model SoldItemIngredient {
  id         String   @id @default(uuid())
  soldItemId String   @index
  ingredient String
  quantity   Float
  unit       String
  shiftId    String   @index
  createdAt DateTime @default(now())
}
‚ö†Ô∏è WARNING TO AGENT
These tables are DERIVED
They must never be written by UI
Only the cascade engine may write here
2Ô∏è‚É£ RECIPE RESOLVER MAP (CANONICAL)
üìÑ server/services/recipeResolver.ts
Copy code
Ts
/**
 * üîí CANONICAL RECIPE RESOLVER
 * ---------------------------
 * Single source of truth for POS ‚Üí Recipe mapping
 */

export const RECIPE_MAP: Record<string, string> = {
  "Single Smash Burger": "Single Smash Burger",
  "Double Smash Burger": "Double Smash Burger",
  "Triple Smash Burger": "Triple Smash Burger",
  "Loaded Fries": "Loaded Fries",
  "Dirty Fries": "Dirty Fries",
  "Cheesy Bacon Fries": "Cheesy Bacon Fries",
  "Chicken Fillet Burger": "Chicken Fillet Burger",
  "El-Smasho Chicken Burger": "El-Smasho Chicken Burger",
  "Karaage Chicken Burger": "Karaage Chicken Burger",
};
‚ö†Ô∏è DO NOT auto-fuzzy-match
‚ö†Ô∏è DO NOT infer quantities here
‚ö†Ô∏è POS naming mismatches are surfaced, not hidden
3Ô∏è‚É£ CORE ENGINE ‚Äî INGREDIENT CASCADE
üìÑ server/services/ingredientCascade.ts
Copy code
Ts
/**
 * üîí INGREDIENT CASCADE ENGINE
 * ---------------------------
 * SoldItem ‚Üí Recipe ‚Üí Ingredient ‚Üí Prep Explosion
 */

import { prisma } from "../prisma";
import { RECIPE_MAP } from "./recipeResolver";

export async function explodeSoldItem(soldItemId: string) {
  const soldItem = await prisma.soldItem.findUnique({
    where: { id: soldItemId },
  });

  if (!soldItem) return;

  const recipeName = RECIPE_MAP[soldItem.name];
  if (!recipeName) return;

  const recipe = await prisma.recipe.findUnique({
    where: { name: recipeName },
    include: { ingredients: true },
  });

  if (!recipe) return;

  await prisma.soldItemRecipe.create({
    data: {
      soldItemId,
      recipeId: recipe.id,
      quantity: 1,
    },
  });

  for (const ing of recipe.ingredients) {
    await explodeIngredient(
      soldItemId,
      soldItem.shiftId,
      ing.ingredientName,
      ing.quantity,
      ing.unit
    );
  }
}

async function explodeIngredient(
  soldItemId: string,
  shiftId: string,
  ingredientName: string,
  qty: number,
  unit: string
) {
  const prepRecipe = await prisma.recipe.findUnique({
    where: { name: ingredientName },
    include: { ingredients: true },
  });

  // BASE INGREDIENT
  if (!prepRecipe || prepRecipe.category !== "PREP") {
    await prisma.soldItemIngredient.create({
      data: {
        soldItemId,
        shiftId,
        ingredient: ingredientName,
        quantity: qty,
        unit,
      },
    });
    return;
  }

  // PREP EXPLOSION
  for (const sub of prepRecipe.ingredients) {
    await prisma.soldItemIngredient.create({
      data: {
        soldItemId,
        shiftId,
        ingredient: sub.ingredientName,
        quantity: sub.quantity * qty,
        unit: sub.unit,
      },
    });
  }
}
4Ô∏è‚É£ EXECUTION HOOK (SAFE)
üìÑ server/workers/postReceiptProcessor.ts
Copy code
Ts
/**
 * üîí POST-RECEIPT DERIVATION ONLY
 */

import { explodeSoldItem } from "../services/ingredientCascade";

export async function processSoldItems(soldItemIds: string[]) {
  for (const id of soldItemIds) {
    await explodeSoldItem(id);
  }
}
‚ö†Ô∏è DO NOT attach this to UI
‚ö†Ô∏è Trigger only after receipts are fully ingested