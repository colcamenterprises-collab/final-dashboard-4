üö® Agent RULES (do this, don‚Äôt do that)

Do NOT drop/truncate any table. No migrate reset.

Do NOT rename columns or tables. This patch auto-detects columns.

Do NOT touch ports, seeds, or .env.

Do NOT add new routes or UI.

DO commit a snapshot first.


Snapshot + commit:

git add -A && git commit -m "pre-rolls-ledger-purchase-fix snapshot"


---

‚úÖ One-shot patch (copy‚Äìpaste, then run)

Save as: apply_rolls_purchase_fix.sh (repo root)
Run: bash apply_rolls_purchase_fix.sh

#!/usr/bin/env bash
set -euo pipefail
echo "== Rolls Ledger purchase-source fix + ensure order =="

mkdir -p prisma/migrations/20251122b_rolls_fix server/services server/jobs

############################################
# 1) DB migration: update recompute to read more sources
############################################
cat > prisma/migrations/20251122b_rolls_fix/migration.sql <<'SQL'
-- Replaces recompute_rolls_ledger with broader purchase-source detection.
-- Sources priority:
--  1) roll_purchase (if exists)
--  2) shopping_purchase_v2 (+ shopping_purchase_item_v2) if present
--  3) expenses (bun/roll in item/name/description) as fallback

CREATE OR REPLACE FUNCTION tbl_exists(tbl text)
RETURNS boolean LANGUAGE sql IMMUTABLE AS $$
  SELECT EXISTS(SELECT 1 FROM information_schema.tables
    WHERE table_schema='public' AND table_name=tbl)
$$;

CREATE OR REPLACE FUNCTION col_exists(tbl text, col text)
RETURNS boolean LANGUAGE sql IMMUTABLE AS $$
  SELECT EXISTS(SELECT 1 FROM information_schema.columns
    WHERE table_schema='public' AND table_name=tbl AND column_name=col)
$$;

CREATE OR REPLACE FUNCTION first_existing_col(tbl text, cols text[])
RETURNS text LANGUAGE plpgsql IMMUTABLE AS $$
DECLARE c text;
BEGIN
  FOREACH c IN ARRAY cols LOOP
    IF (SELECT col_exists(tbl, c)) THEN
      RETURN c;
    END IF;
  END LOOP;
  RETURN NULL;
END$$;

CREATE OR REPLACE FUNCTION recompute_rolls_ledger(p_date date)
RETURNS void LANGUAGE plpgsql AS $$
DECLARE
  v_prev date := (p_date - INTERVAL '1 day')::date;

  stock_tbl text := CASE
                      WHEN tbl_exists('daily_stock_sales') THEN 'daily_stock_sales'
                      WHEN tbl_exists('DailyStock') THEN 'DailyStock'
                      ELSE NULL
                    END;
  stock_end_col text;
  stock_date_col text;

  v_start int := 0;
  v_purchased int := 0;
  v_sold int := 0;
  v_est int := 0;
  v_actual int := NULL;
  v_waste int := 4;
  v_var int := NULL;

  sql text;
  -- shopping tables detection
  sp_items_tbl text := CASE WHEN tbl_exists('shopping_purchase_item_v2') THEN 'shopping_purchase_item_v2' ELSE NULL END;
  sp_head_tbl  text := CASE WHEN tbl_exists('shopping_purchase_v2')     THEN 'shopping_purchase_v2'     ELSE NULL END;

  item_qty_col text;
  item_name_col text;
  item_fk_col text;
  head_pk_col text;
  head_date_col text;
BEGIN
  -- START = yesterday actual (ledger first, else DailyStock/DSS)
  SELECT rl.actual_rolls_end INTO v_start FROM rolls_ledger rl WHERE rl.shift_date = v_prev;
  IF v_start IS NULL AND stock_tbl IS NOT NULL THEN
    stock_end_col := first_existing_col(stock_tbl, ARRAY['burger_buns_stock','rolls_end','buns_end','rolls_actual','buns_stock']);
    IF stock_end_col IS NOT NULL THEN
      IF stock_tbl = 'daily_stock_sales' THEN
        sql := format('SELECT %I FROM %I WHERE shift_date=$1 ORDER BY COALESCE(updated_at,created_at) DESC LIMIT 1',
                      stock_end_col, stock_tbl);
        EXECUTE sql USING v_prev INTO v_start;
      ELSE
        stock_date_col := CASE WHEN col_exists('DailyStock','shift_date') THEN 'shift_date' ELSE NULL END;
        IF stock_date_col IS NOT NULL THEN
          sql := format('SELECT %I FROM "DailyStock" WHERE %I=$1 ORDER BY COALESCE("updatedAt","createdAt") DESC LIMIT 1',
                        stock_end_col, stock_date_col);
          EXECUTE sql USING v_prev INTO v_start;
        ELSE
          sql := format('SELECT %I FROM "DailyStock"
                         WHERE DATE(COALESCE("updatedAt","createdAt"))=$1
                         ORDER BY COALESCE("updatedAt","createdAt") DESC LIMIT 1', stock_end_col);
          EXECUTE sql USING v_prev INTO v_start;
        END IF;
      END IF;
    END IF;
  END IF;
  IF v_start IS NULL THEN v_start := 0; END IF;

  -- PURCHASED (priority order)

  -- 1) roll_purchase
  IF tbl_exists('roll_purchase') THEN
    IF col_exists('roll_purchase','shift_date') THEN
      EXECUTE 'SELECT COALESCE(SUM(quantity),0)::int FROM roll_purchase WHERE shift_date=$1'
      USING p_date INTO v_purchased;
    ELSE
      EXECUTE 'SELECT COALESCE(SUM(quantity),0)::int FROM roll_purchase WHERE DATE(purchase_ts)=$1'
      USING p_date INTO v_purchased;
    END IF;
  END IF;

  -- 2) shopping_purchase_v2 + shopping_purchase_item_v2 (if present)
  IF v_purchased = 0 AND sp_items_tbl IS NOT NULL AND sp_head_tbl IS NOT NULL THEN
    item_qty_col := first_existing_col(sp_items_tbl, ARRAY['quantity','qty','units','number']);
    item_name_col := first_existing_col(sp_items_tbl, ARRAY['item','name','description','product']);
    item_fk_col  := first_existing_col(sp_items_tbl, ARRAY['purchase_id','shopping_purchase_id','header_id','sp_id','parent_id']);

    head_pk_col   := first_existing_col(sp_head_tbl, ARRAY['id','purchase_id','sp_id','uuid']);
    head_date_col := first_existing_col(sp_head_tbl, ARRAY['shift_date','purchase_date','date','purchased_at','created_at','createdAt']);

    IF item_qty_col IS NOT NULL AND item_name_col IS NOT NULL AND item_fk_col IS NOT NULL
       AND head_pk_col IS NOT NULL AND head_date_col IS NOT NULL THEN
      sql := format($SQL$
        SELECT COALESCE(SUM(i.%I),0)::int
        FROM %I i
        JOIN %I h ON i.%I = h.%I
        WHERE DATE(h.%I) = $1
          AND (lower(i.%I) LIKE '%%bun%%' OR lower(i.%I) LIKE '%%roll%%')
      $SQL$, item_qty_col, sp_items_tbl, sp_head_tbl, item_fk_col, head_pk_col, head_date_col, item_name_col, item_name_col);
      EXECUTE sql USING p_date INTO v_purchased;
    END IF;
  END IF;

  -- 3) expenses fallback (bun/roll in text)
  IF v_purchased = 0 AND tbl_exists('expenses') THEN
    DECLARE exp_qty_col text := first_existing_col('expenses', ARRAY['quantity','qty','units','number']);
    DECLARE exp_item_col text := first_existing_col('expenses', ARRAY['item','name','description','product']);
    DECLARE exp_date_col text := first_existing_col('expenses', ARRAY['shift_date','date','ts','created_at','createdAt']);
  BEGIN
    IF exp_qty_col IS NOT NULL AND exp_item_col IS NOT NULL AND exp_date_col IS NOT NULL THEN
      sql := format($SQL$
        SELECT COALESCE(SUM(%I),0)::int
        FROM expenses
        WHERE (lower(%I) LIKE '%%bun%%' OR lower(%I) LIKE '%%roll%%')
          AND DATE(%I) = $1
      $SQL$, exp_qty_col, exp_item_col, exp_item_col, exp_date_col);
      EXECUTE sql USING p_date INTO v_purchased;
    END IF;
  END;
  END IF;

  -- SOLD from analytics_shift_item (prefer 'rolls', fallback burgers qty)
  IF tbl_exists('analytics_shift_item') THEN
    EXECUTE 'SELECT COALESCE(SUM(rolls),0)::int FROM analytics_shift_item WHERE shift_date=$1'
    USING p_date INTO v_sold;
    IF v_sold = 0 THEN
      EXECUTE $$SELECT COALESCE(SUM(qty),0)::int FROM analytics_shift_item
               WHERE shift_date=$1 AND lower(category)='burger'$$
      USING p_date INTO v_sold;
    END IF;
  END IF;

  -- ACTUAL end from Daily Stock/DailyStock
  IF stock_tbl IS NOT NULL THEN
    stock_end_col := first_existing_col(stock_tbl, ARRAY['burger_buns_stock','rolls_end','buns_end','rolls_actual','buns_stock']);
    IF stock_end_col IS NOT NULL THEN
      IF stock_tbl = 'daily_stock_sales' THEN
        sql := format('SELECT %I FROM %I WHERE shift_date=$1 ORDER BY COALESCE(updated_at,created_at) DESC LIMIT 1',
                      stock_end_col, stock_tbl);
        EXECUTE sql USING p_date INTO v_actual;
      ELSE
        stock_date_col := CASE WHEN col_exists('DailyStock','shift_date') THEN 'shift_date' ELSE NULL END;
        IF stock_date_col IS NOT NULL THEN
          sql := format('SELECT %I FROM "DailyStock" WHERE %I=$1 ORDER BY COALESCE("updatedAt","createdAt") DESC LIMIT 1',
                        stock_end_col, stock_date_col);
          EXECUTE sql USING p_date INTO v_actual;
        ELSE
          sql := format('SELECT %I FROM "DailyStock"
                         WHERE DATE(COALESCE("updatedAt","createdAt"))=$1
                         ORDER BY COALESCE("updatedAt","createdAt") DESC LIMIT 1', stock_end_col);
          EXECUTE sql USING p_date INTO v_actual;
        END IF;
      END IF;
    END IF;
  END IF;

  -- Assemble
  v_est := v_start + v_purchased - v_sold;

  IF v_actual IS NULL THEN
    INSERT INTO rolls_ledger(shift_date, rolls_start, rolls_purchased, burgers_sold,
                             estimated_rolls_end, actual_rolls_end, waste_allowance,
                             variance, status, updated_at)
    VALUES (p_date, v_start, v_purchased, v_sold, v_est, NULL, 4, NULL, 'PENDING', now())
    ON CONFLICT (shift_date) DO UPDATE SET
      rolls_start=EXCLUDED.rolls_start, rolls_purchased=EXCLUDED.rolls_purchased,
      burgers_sold=EXCLUDED.burgers_sold, estimated_rolls_end=EXCLUDED.estimated_rolls_end,
      actual_rolls_end=NULL, variance=NULL, status='PENDING', updated_at=now();
  ELSE
    v_var := v_actual - v_est;
    INSERT INTO rolls_ledger(shift_date, rolls_start, rolls_purchased, burgers_sold,
                             estimated_rolls_end, actual_rolls_end, waste_allowance,
                             variance, status, updated_at)
    VALUES (p_date, v_start, v_purchased, v_sold, v_est, v_actual, 4,
            v_var, CASE WHEN abs(v_var)<=4 THEN 'OK' ELSE 'ALERT' END, now())
    ON CONFLICT (shift_date) DO UPDATE SET
      rolls_start=EXCLUDED.rolls_start, rolls_purchased=EXCLUDED.rolls_purchased,
      burgers_sold=EXCLUDED.burgers_sold, estimated_rolls_end=EXCLUDED.estimated_rolls_end,
      actual_rolls_end=EXCLUDED.actual_rolls_end, variance=EXCLUDED.variance,
      status=EXCLUDED.status, updated_at=now();
  END IF;
END;
$$;
SQL

############################################
# 2) TS fixes: make sure imports/executeRaw are correct
############################################
cat > server/services/rollsLedgerSimple.ts <<'TS'
import { PrismaClient } from "@prisma/client";
const db = new PrismaClient();

export async function recomputeRollsLedgerByShiftDate(shiftDate: string) {
  await db.$executeRaw`SELECT recompute_rolls_ledger(${shiftDate}::date)`;
}
TS

cat > server/services/ensureShift.ts <<'TS'
import { PrismaClient } from "@prisma/client";
import { recomputeRollsLedgerByShiftDate } from "./rollsLedgerSimple";
const db = new PrismaClient();

async function importFromLoyverse(shiftDate: string): Promise<number> {
  try {
    const mod = await import("../services/loyverseImportV2");
    if (typeof (mod as any).importShift === "function") {
      const r = await (mod as any).importShift(shiftDate);
      return Number(r?.receipts ?? r?.imported ?? 0);
    }
    if (typeof (mod as any).syncShift === "function") {
      const r = await (mod as any).syncShift(shiftDate);
      return Number(r?.receipts ?? r?.imported ?? 0);
    }
    if (typeof (mod as any).syncRange === "function") {
      const r = await (mod as any).syncRange(shiftDate, shiftDate);
      return Number(r?.receipts ?? r?.imported ?? 0);
    }
  } catch {}
  return 0;
}

async function cacheHasDate(shiftDate: string): Promise<boolean> {
  const r:any[] = await db.$queryRaw`
    SELECT COUNT(*)::int AS n FROM analytics_shift_item WHERE shift_date = ${shiftDate}::date
  `;
  return Number(r?.[0]?.n ?? 0) > 0;
}

async function computeShiftAll(shiftDate: string): Promise<void> {
  const svc = await import("./shiftItems");
  if (typeof (svc as any).computeShiftAll === "function") {
    await (svc as any).computeShiftAll(shiftDate);
  }
}

export async function ensureShift(shiftDate: string): Promise<void> {
  if (!(await cacheHasDate(shiftDate))) {
    const rc:any[] = await db.$queryRaw`
      SELECT COUNT(*)::int AS n
      FROM lv_receipt
      WHERE (DATE(datetime_bkk AT TIME ZONE 'Asia/Bangkok')) IN (${shiftDate}::date, (${shiftDate}::date + INTERVAL '1 day')::date)
    `;
    if (Number(rc?.[0]?.n ?? 0) === 0) {
      await importFromLoyverse(shiftDate);
    }
    // 1) compute analytics first
    await computeShiftAll(shiftDate);
  }
  // 2) then recompute the rolls ledger (ensures burgers_sold isn't stale)
  await recomputeRollsLedgerByShiftDate(shiftDate);
}
TS

cat > server/jobs/cronEnsureShift.ts <<'TS'
import cron from "node-cron";
import { ensureShift } from "../services/ensureShift";

function yesterdayYMD() {
  const now = new Date(new Date().toLocaleString("en-US",{ timeZone:"Asia/Bangkok"}));
  now.setDate(now.getDate() - 1);
  const y = now.getFullYear();
  const m = String(now.getMonth()+1).padStart(2,"0");
  const d = String(now.getDate()).padStart(2,"0");
  return `${y}-${m}-${d}`;
}

export function registerEnsureShiftCron() {
  cron.schedule("5 3 * * *", async () => {
    try { await ensureShift(yesterdayYMD()); } catch {}
  }, { timezone: "Asia/Bangkok" });
}
TS

############################################
# 3) Ensure route still calls ensureShift on cache miss
############################################
ROUTE_FILE="server/routes/shiftAnalysis.ts"
if [ -f "$ROUTE_FILE" ]; then
  if ! grep -q "ensureShift" "$ROUTE_FILE"; then
    sed -i "1 i import { ensureShift } from '../services/ensureShift';" "$ROUTE_FILE"
    awk '
      BEGIN{patched=0}
      /router\.get\(.+\/api\/analysis\/shift\/items/ {print; inroute=1; next}
      inroute==1 && /\{.*req.*res/ && patched==0 {
        print; print "  try {"; print "    const date = String((req.query.date||\"\"));";
        print "    if (date) await ensureShift(date.slice(0,10));"; print "  } catch {}";
        patched=1; inroute=0; next
      }
      {print}
    ' "$ROUTE_FILE" > "$ROUTE_FILE.tmp" && mv "$ROUTE_FILE.tmp" "$ROUTE_FILE"
    echo "Patched $ROUTE_FILE to call ensureShift()"
  else
    echo "Route already ensures shift; leaving as-is."
  fi
else
  echo "WARNING: $ROUTE_FILE not found. Manually ensure the handler calls ensureShift(date)."
fi

############################################
# 4) Apply DB changes
############################################
npx prisma migrate deploy || npx prisma db push

echo "== Done. Purchases now detected from roll_purchase or shopping_purchase_v2(+items), then expenses as fallback =="


---

üîé Quick verification (agent must run)

1. Ensure + fetch



curl -s "http://localhost:3001/api/analysis/shift/items?date=2025-11-21" | head

2. Read analytics + purchases + ledger



-- Rolls sold (should match the page ‚Äòrolls‚Äô total)
SELECT SUM(rolls) AS rolls_sold
FROM analytics_shift_item
WHERE shift_date='2025-11-21';

-- Purchases detected from each source (see where 120 is)
SELECT 'roll_purchase' src, COALESCE(SUM(quantity),0) q
FROM roll_purchase WHERE shift_date='2025-11-21'
UNION ALL
SELECT 'shopping_purchase_v2+items',
  COALESCE(SUM(i.quantity),0)
FROM shopping_purchase_item_v2 i
JOIN shopping_purchase_v2 h ON i.shopping_purchase_id=h.id
WHERE DATE(h.shift_date)=DATE '2025-11-21'
  AND (lower(i.name) LIKE '%bun%' OR lower(i.name) LIKE '%roll%')
UNION ALL
SELECT 'expenses',
  COALESCE(SUM(quantity),0)
FROM expenses
WHERE DATE(COALESCE(shift_date, date, ts, created_at, "createdAt"))='2025-11-21'
  AND (lower(COALESCE(item,name,description,product)) LIKE '%bun%'
       OR lower(COALESCE(item,name,description,product)) LIKE '%roll%');

-- Final ledger row
SELECT * FROM rolls_ledger WHERE shift_date='2025-11-21';

3. Daily Stock form submission check



If actual_rolls_end is still NULL, submit the Daily Stock V2 for that date.

Re-query rolls_ledger ‚Äî status should flip to OK/ALERT (¬±4).



---

‚úÖ Acceptance Criteria (agent checks off)

Opening /analysis/fb?date=YYYY-MM-DD shows items and the ledger populated for the same shift_date.

burgers_sold in rolls_ledger equals the ‚Äúrolls‚Äù total from analytics_shift_item.

rolls_purchased equals the sum in roll_purchase or shopping_purchase_v2 (+items); if neither exists, equals the buns/rolls total in expenses.

Submitting/changing the Daily Stock for that shift_date updates actual_rolls_end and status.



---