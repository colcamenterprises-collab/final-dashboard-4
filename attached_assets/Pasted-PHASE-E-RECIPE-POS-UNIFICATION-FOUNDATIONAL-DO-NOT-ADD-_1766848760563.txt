PHASE E â€” RECIPE & POS UNIFICATION (FOUNDATIONAL)
âš ï¸ DO NOT ADD FEATURES | NO UI REDESIGN | NO NAVIGATION CHANGES
ğŸ¯ OBJECTIVE (NON-NEGOTIABLE)
Eliminate recipe ambiguity by establishing one canonical recipe system and explicit POS â†’ Recipe ownership, without breaking live operations.
This patch does not optimise, redesign, or extend functionality.
It only unifies, locks, and labels existing systems so downstream analytics, costing, and purchasing can finally be trusted.
ğŸ”’ RULES (ABSOLUTE)
NO new pages
NO analytics changes
NO Form 2 changes
NO purchasing changes
NO modifier handling (explicitly deferred)
NO deletion of legacy data
NO silent migrations
READ / MAP / LOCK / LABEL ONLY
If a change violates these rules, DO NOT IMPLEMENT IT.
ğŸ“ CANONICAL DECLARATIONS (ENFORCE IN CODE)
1ï¸âƒ£ Recipe Authority
Canonical recipe system:
server/services/recipeAuthority.ts
Canonical table:
recipe + recipe_ingredient
All recipe costing must be derived live from:
purchasing_items.unit_cost
No cached costs anywhere
2ï¸âƒ£ POS vs Recipe Separation (CRITICAL)
Define and enforce the following mental model in code:
Concept
Meaning
POS Item
What is sold
Recipe
How it is made
Purchasing Item
Cost input
Menu
Presentation layer only
POS items are NOT recipes.
Recipes are NOT menu items.
ğŸ§± PHASE E TASKS (EXECUTE IN ORDER)
TASK E1 â€” Freeze Legacy Recipe Systems
READ-ONLY ENFORCEMENT
Identify all legacy recipe sources:
recipes table (legacy)
/menu/recipes
/menu/cost-calculator
Ensure:
No POST / PUT / DELETE routes mutate legacy recipes
UI actions are disabled
Clear amber banner:
â€œRead-Only â€” Recipes are now managed in Recipe Managementâ€
ğŸš« Do NOT delete legacy tables
ğŸš« Do NOT migrate data yet
TASK E2 â€” Introduce Explicit POS â†’ Recipe Mapping
NO AUTO-MATCHING
Use existing table:
pos_item_recipe_map
Enforce rules:
One POS item â†’ zero or one recipe
Mapping must be explicit (ID â†’ ID)
No name-based inference
Add guard logic:
If POS item has no recipe, flag as:
UNMAPPED_POS_ITEM
âš ï¸ Do NOT surface errors to staff yet
âš ï¸ Logging + internal flags only
TASK E3 â€” Recipe Completeness Guard
DATA INTEGRITY ONLY
A recipe may be marked active = true ONLY IF:
All ingredients exist
All ingredients reference:
purchasing_items.is_ingredient = true
purchasing_items.active = true
If not:
Recipe remains inactive
Return reason code:
Copy code

RECIPE_INCOMPLETE
ğŸš« Do NOT auto-fix
ğŸš« Do NOT modify purchasing items
TASK E4 â€” Cost Authority Lock
SINGLE SOURCE OF TRUTH
Remove / block any alternate cost calculations
All recipe cost APIs must:
Copy code

SUM(
  recipe_ingredient.quantity 
  Ã— purchasing_items.unit_cost
)
Verify no other services compute recipe costs
Add inline comment headers:
Copy code
Ts
// ğŸ”’ CANONICAL COST AUTHORITY â€” DO NOT DUPLICATE
TASK E5 â€” Visibility Labels (NO UI CHANGES)
Add read-only labels only, no redesign:
Legacy recipe pages:
â€œRead-Only â€” Legacy Recipe Viewâ€
Recipe Management:
â€œCanonical Recipe Editorâ€
POS items without recipes:
Internal status flag only (not staff-facing)
TASK E6 â€” Debug & Verification Endpoints
INTERNAL USE ONLY
Add:
Copy code

GET /api/debug/recipe-pos-parity
Response shape:
Copy code
Json
{
  "posItems": 123,
  "mapped": 87,
  "unmapped": 36,
  "activeRecipes": 42,
  "inactiveRecipes": 3
}
ğŸš« No auth changes
ğŸš« No frontend consumption yet
ğŸ§ª VERIFICATION CHECKLIST (MANDATORY)
Agent must confirm:
âœ… Only /recipe-management allows edits
âœ… Legacy recipe pages cannot mutate data
âœ… POS items no longer masquerade as recipes
âœ… Recipe cost changes when purchasing cost changes
âœ… No crashes if POS item has no recipe
âœ… App boots cleanly
âœ… No navigation changes
ğŸ§¯ FAILURE CONDITIONS (STOP IMMEDIATELY)
If any of the following occur:
A legacy recipe becomes editable
Costs diverge between systems
Purchasing logic is touched
Form 2 logic is modified
Navigation is altered
â†’ STOP AND REPORT
ğŸ§  END STATE (WHAT SUCCESS LOOKS LIKE)
After Phase E:
There is exactly one recipe system
POS items are explicitly mapped, not guessed
Costs are always correct
Purchasing â†’ Ingredients â†’ Recipes â†’ POS is now a clean chain
You can finally build:
Modifier logic
True food usage
Reliable anomalies
Prime cost
Proceed immediately.
No questions.
No optimisations.
No creativity.