üõë Replit Agent Instructions

Only replace server/forms/dailySalesV2.ts and client/src/pages/operations/daily-sales/Form.tsx.

Do not modify schema, routes, or unrelated files.

Do not edit package.json.

Do not auto-‚Äúfix‚Äù DB structure.

1. server/forms/dailySalesV2.ts
import { Request, Response } from "express";
import pool from "@/server/db";
import { toCents, fromCents } from "@/lib/utils";
import nodemailer from "nodemailer";
import { v4 as uuidv4 } from "uuid";

const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS,
  },
});

export async function createDailySalesV2(req: Request, res: Response) {
  try {
    const {
      completedBy,
      startingCash,
      cashSales,
      qrSales,
      grabSales,
      otherSales,
      expenses,
      wages,
      closingCash,
      requisition,
      rollsEnd,
      meatEnd,
    } = req.body;

    const id = uuidv4();
    const shiftDate = new Date().toISOString().split("T")[0];
    const createdAt = new Date().toISOString();

    // Totals
    const totalSales =
      toCents(cashSales) +
      toCents(qrSales) +
      toCents(grabSales) +
      toCents(otherSales);

    const totalExpenses =
      (expenses || []).reduce((s: number, e: any) => s + toCents(e.cost), 0) +
      (wages || []).reduce((s: number, w: any) => s + toCents(w.amount), 0);

    // Expected register = Starting + Cash ‚Äì Expenses
    const expectedClosingCash =
      toCents(startingCash) + toCents(cashSales) - totalExpenses;

    const closingCashCents = toCents(closingCash);

    // Balanced check ¬±30
    const diff = Math.abs(expectedClosingCash - closingCashCents);
    const balanced = diff <= toCents(30);

    // Banked amounts
    const cashBanked = closingCashCents - toCents(startingCash);
    const qrTransfer = toCents(qrSales);

    const payload = {
      completedBy,
      startingCash: toCents(startingCash),
      cashSales: toCents(cashSales),
      qrSales: toCents(qrSales),
      grabSales: toCents(grabSales),
      otherSales: toCents(otherSales),
      expenses,
      wages,
      closingCash: closingCashCents,
      totalSales,
      totalExpenses,
      expectedClosingCash,
      balanced,
      cashBanked: cashBanked < 0 ? 0 : cashBanked,
      qrTransfer,
      requisition,
      rollsEnd,
      meatEnd,
    };

    await pool.query(
      `INSERT INTO daily_sales_v2 (id, shiftDate, completedBy, created_at, payload)
       VALUES ($1, $2, $3, $4, $5)`,
      [id, shiftDate, completedBy, createdAt, payload]
    );

    // Build shopping list
    const shoppingItems = (requisition || [])
      .filter((i: any) => (i.qty || 0) > 0)
      .map((i: any) => `${i.name} ‚Äì ${i.qty} ${i.unit}`);

    // Email
    const html = `
      <h2>Daily Sales & Stock Report</h2>
      <p><strong>Date:</strong> ${shiftDate}</p>
      <p><strong>Completed By:</strong> ${completedBy}</p>

      <h3>Sales</h3>
      <ul>
        <li>Cash Sales: ‡∏ø${fromCents(toCents(cashSales))}</li>
        <li>QR Sales: ‡∏ø${fromCents(toCents(qrSales))}</li>
        <li>Grab Sales: ‡∏ø${fromCents(toCents(grabSales))}</li>
        <li>Other Sales: ‡∏ø${fromCents(toCents(otherSales))}</li>
        <li><strong>Total Sales:</strong> ‡∏ø${fromCents(totalSales)}</li>
      </ul>

      <h3>Expenses</h3>
      <ul>
        ${(expenses || [])
          .map(
            (e: any) =>
              `<li>${e.item} ‚Äì ‡∏ø${fromCents(toCents(e.cost))} (${e.shop})</li>`
          )
          .join("")}
        ${(wages || [])
          .map(
            (w: any) =>
              `<li>${w.staff} ‚Äì ‡∏ø${fromCents(toCents(w.amount))} (${w.type})</li>`
          )
          .join("")}
      </ul>
      <p><strong>Total Expenses:</strong> ‡∏ø${fromCents(totalExpenses)}</p>

      <h3>Banking</h3>
      <ul>
        <li>Total Cash in Register (Closing Cash): ‡∏ø${fromCents(closingCashCents)}</li>
        <li>Expected Register: ‡∏ø${fromCents(expectedClosingCash)}</li>
        <li>
          Balanced: ${
            balanced
              ? '<span style="color:green;font-weight:bold">YES ‚úÖ</span>'
              : '<span style="color:red;font-weight:bold">NO ‚ùå</span>'
          }
        </li>
        <li>Cash to Bank: ‡∏ø${fromCents(cashBanked)}</li>
        <li>QR to Bank: ‡∏ø${fromCents(qrTransfer)}</li>
      </ul>

      <h3>Stock</h3>
      <ul>
        <li>Rolls: ${rollsEnd || "-"}</li>
        <li>Meat: ${meatEnd || "-"}</li>
      </ul>

      <h3>Shopping List</h3>
      ${
        shoppingItems.length === 0
          ? "<p>No items to purchase</p>"
          : `<ul>${shoppingItems.map((s) => `<li>${s}</li>`).join("")}</ul>`
      }
    `;

    await transporter.sendMail({
      from: `"SBB Dashboard" <${process.env.SMTP_USER}>`,
      to: process.env.MANAGEMENT_EMAIL,
      cc: "smashbrothersburgersth@gmail.com",
      subject: `Daily Sales & Stock ‚Äì ${shiftDate}`,
      html,
    });

    res.json({ ok: true, id });
  } catch (err) {
    console.error("Daily Sales V2 error", err);
    res.status(500).json({ ok: false, error: "Failed to save record" });
  }
}

2. client/src/pages/operations/daily-sales/Form.tsx
import React, { useState } from "react";

export default function DailySalesForm() {
  const [formData, setFormData] = useState({
    completedBy: "",
    startingCash: 2000,
    cashSales: 0,
    qrSales: 0,
    grabSales: 0,
    otherSales: 0,
    expenses: [] as { item: string; cost: number; shop?: string }[],
    wages: [] as { staff: string; amount: number; type: string }[],
    closingCash: 0,
    requisition: [] as any[],
    rollsEnd: 0,
    meatEnd: 0,
  });

  const [balanced, setBalanced] = useState<boolean | null>(null);

  function handleChange(e: React.ChangeEvent<HTMLInputElement>) {
    const { name, value } = e.target;
    const parsed = Number(value) || 0;
    const updated = { ...formData, [name]: parsed };
    setFormData(updated);

    if (name === "closingCash") {
      const totalExpenses =
        (formData.expenses || []).reduce((s, e) => s + (e.cost || 0), 0) +
        (formData.wages || []).reduce((s, w) => s + (w.amount || 0), 0);

      const expected =
        Number(formData.startingCash) + Number(formData.cashSales) - totalExpenses;

      const diff = Math.abs(expected - parsed);
      setBalanced(diff <= 30);
    }
  }

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    await fetch("/api/forms/daily-sales/v2", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(formData),
    });
    alert("Form submitted successfully!");
  }

  return (
    <form
      onSubmit={handleSubmit}
      className="p-4 space-y-6 grid grid-cols-1 md:grid-cols-2 gap-4 font-[Poppins]"
    >
      {/* Sales Section */}
      <div>
        <h2 className="text-lg font-bold mb-2">Sales</h2>
        <input type="text" name="completedBy" placeholder="Completed By" onChange={handleChange} className="w-full border p-2 mb-2 rounded" />
        <input type="number" name="startingCash" value={formData.startingCash} placeholder="Starting Cash" onChange={handleChange} className="w-full border p-2 mb-2 rounded" />
        <input type="number" name="cashSales" placeholder="Cash Sales" onChange={handleChange} className="w-full border p-2 mb-2 rounded" />
        <input type="number" name="qrSales" placeholder="QR Sales" onChange={handleChange} className="w-full border p-2 mb-2 rounded" />
        <input type="number" name="grabSales" placeholder="Grab Sales" onChange={handleChange} className="w-full border p-2 mb-2 rounded" />
        <input type="number" name="otherSales" placeholder="Other Sales" onChange={handleChange} className="w-full border p-2 mb-2 rounded" />
      </div>

      {/* Stock Section */}
      <div>
        <h2 className="text-lg font-bold mb-2">Stock</h2>
        <input type="number" name="rollsEnd" placeholder="Rolls Remaining" onChange={handleChange} className="w-full border p-2 mb-2 rounded" />
        <input type="number" name="meatEnd" placeholder="Meat Remaining (g)" onChange={handleChange} className="w-full border p-2 mb-2 rounded" />
      </div>

      {/* Banking Section */}
      <div className="md:col-span-2">
        <h2 className="text-lg font-bold mb-2">Banking</h2>

        {/* Input 1: Closing Cash */}
        <input
          type="number"
          name="closingCash"
          placeholder="Total Cash in Register at Close"
          onChange={handleChange}
          className="w-full border p-2 mb-2 rounded"
        />

        {/* Input 2: Balanced Status */}
        {balanced !== null && (
          <div
            className={`p-2 mt-2 rounded ${
              balanced ? "bg-green-100 text-green-700" : "bg-red-100 text-red-700"
            }`}
          >
            {balanced ? "Balanced ‚úÖ" : "Not Balanced ‚ùå"}
          </div>
        )}

        {/* Input 3: Cash to Bank */}
        <input
          type="number"
          name="cashBanked"
          placeholder="Cash to Bank (auto)"
          value={Number(formData.closingCash) - Number(formData.startingCash)}
          readOnly
          className="w-full border p-2 mb-2 rounded bg-gray-100 text-gray-600"
        />

        {/* Input 4: QR to Bank */}
        <input
          type="number"
          name="qrTransfer"
          placeholder="QR to Bank (auto)"
          value={formData.qrSales}
          readOnly
          className="w-full border p-2 mb-2 rounded bg-gray-100 text-gray-600"
        />
      </div>

      {/* Submit */}
      <div className="md:col-span-2 flex justify-end">
        <button type="submit" className="px-4 py-2 bg-black text-white rounded-lg">
          Submit
        </button>
      </div>
    </form>
  );
}


‚úÖ With this golden pair:

Form has exactly 4 banking fields: Closing Cash (manual), Balanced badge (auto), Cash to Bank (auto), QR to Bank (auto).

Backend calculates with the same formulas, saves to DB, sends correct email.

No schema edits needed (id, shiftDate, completedBy, created_at, payload).

Shopping List still included in payload + email.