Data sources (do NOT invent new ones)

Total Sales (฿) → daily_sales_v2.total_sales for that shift_date

Wages (฿) → daily_sales_v2.wages_total for that shift_date

Food & Beverage (฿) → Business Expenses modal entries on that same shift_date where category is Food & Beverage (see mapping below)


Column/table mapping (agent must pin these once)

> Do not proceed until these probes succeed and you paste the exact names into the constants below.



Schema probes (run in SQL console):

-- 1) Daily sales v2
SELECT column_name FROM information_schema.columns
WHERE table_schema='public' AND table_name='daily_sales_v2';

-- 2) Business expenses (the modal you use for F&B)
SELECT table_name FROM information_schema.tables
WHERE table_schema='public' AND table_name IN ('business_expense','expenses','expense');

-- Inspect columns of the chosen table
SELECT column_name FROM information_schema.columns
WHERE table_schema='public' AND table_name='business_expense';

Expected minimum fields

daily_sales_v2: shift_date (date), total_sales (numeric), wages_total (numeric)

business_expense (or expenses): date (date), category (text), amount (numeric)


If your expenses table is named differently or columns differ, set the constants below accordingly.


---

Backend — add a small metrics endpoint

Create server/services/primeCost.ts:

import { PrismaClient } from "@prisma/client";

const db = new PrismaClient();

/**
 * PIN THESE CONSTANTS TO YOUR ACTUAL SCHEMA NAMES.
 * Agent: set these from the schema probes. Do not guess.
 */
const EXPENSES_TABLE = "business_expense";   // e.g. 'business_expense' or 'expenses'
const EXP_DATE_COL   = "date";               // e.g. 'date'
const EXP_CAT_COL    = "category";           // e.g. 'category'
const EXP_AMT_COL    = "amount";             // e.g. 'amount'

const DS_TABLE       = "daily_sales_v2";     // daily sales v2 table
const DS_DATE_COL    = "shift_date";         // 'shift_date'
const DS_SALES_COL   = "total_sales";        // 'total_sales'
const DS_WAGES_COL   = "wages_total";        // 'wages_total'

// category normalisation for Food & Beverage
const FNB_MATCH = [
  "food & beverage", "food and beverage", "f&b", "food", "beverage"
];

function ymd(d: Date) {
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, "0");
  const day = String(d.getDate()).padStart(2, "0");
  return `${y}-${m}-${day}`;
}

/** Returns the most recent shift_date present in daily_sales_v2. */
export async function getLatestShiftDate(): Promise<string | null> {
  const rows: any[] = await db.$queryRawUnsafe(
    `SELECT MAX(${DS_DATE_COL}) AS d FROM ${DS_TABLE}`
  );
  return rows?.[0]?.d ?? null;
}

type PrimeCostRow = {
  date: string;
  sales: number;
  wages: number;
  fnb: number;
  primeCost: number;
  primePct: number | null;
};

export async function getPrimeCostForDate(dateYMD: string): Promise<PrimeCostRow> {
  // Sales + Wages from daily_sales_v2
  const ds: any[] = await db.$queryRawUnsafe(
    `SELECT ${DS_SALES_COL} AS sales, ${DS_WAGES_COL} AS wages
     FROM ${DS_TABLE}
     WHERE ${DS_DATE_COL} = $1
     LIMIT 1`, dateYMD
  );
  const sales = Number(ds?.[0]?.sales ?? 0);
  const wages = Number(ds?.[0]?.wages ?? 0);

  // F&B from Business Expenses modal (strict same-day match)
  const fnb: any[] = await db.$queryRawUnsafe(
    `SELECT COALESCE(SUM(${EXP_AMT_COL}),0) AS amt
     FROM ${EXPENSES_TABLE}
     WHERE DATE(${EXP_DATE_COL}) = $1
       AND LOWER(${EXP_CAT_COL}) IN (${FNB_MATCH.map((_,i)=>`$${i+2}`).join(",")})`,
       dateYMD, ...FNB_MATCH
  );
  const fnbAmt = Number(fnb?.[0]?.amt ?? 0);

  const primeCost = wages + fnbAmt;
  const primePct = sales > 0 ? (primeCost / sales) * 100 : null;

  return {
    date: dateYMD,
    sales,
    wages,
    fnb: fnbAmt,
    primeCost,
    primePct
  };
}

export async function getPrimeCostMTD(dateYMD: string) {
  const d = new Date(dateYMD + "T00:00:00Z");
  const start = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), 1));
  const end = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth()+1, 1));
  const startY = ymd(start), endY = ymd(end);

  const ds: any[] = await db.$queryRawUnsafe(
    `SELECT
       COALESCE(SUM(${DS_SALES_COL}),0) AS sales,
       COALESCE(SUM(${DS_WAGES_COL}),0) AS wages
     FROM ${DS_TABLE}
     WHERE ${DS_DATE_COL} >= $1 AND ${DS_DATE_COL} < $2`,
     startY, endY
  );
  const sales = Number(ds?.[0]?.sales ?? 0);
  const wages = Number(ds?.[0]?.wages ?? 0);

  const fnb: any[] = await db.$queryRawUnsafe(
    `SELECT COALESCE(SUM(${EXP_AMT_COL}),0) AS amt
     FROM ${EXPENSES_TABLE}
     WHERE DATE(${EXP_DATE_COL}) >= $1 AND DATE(${EXP_DATE_COL}) < $2
       AND LOWER(${EXP_CAT_COL}) IN (${FNB_MATCH.map((_,i)=>`$${i+3}`).join(",")})`,
     startY, endY, ...FNB_MATCH
  );
  const fnbAmt = Number(fnb?.[0]?.amt ?? 0);

  const primeCost = wages + fnbAmt;
  const primePct = sales > 0 ? (primeCost / sales) * 100 : null;

  return {
    start: startY,
    end: endY,
    sales,
    wages,
    fnb: fnbAmt,
    primeCost,
    primePct
  };
}

Create server/routes/primeCost.ts:

import { Router } from "express";
import { getLatestShiftDate, getPrimeCostForDate, getPrimeCostMTD } from "../services/primeCost.js";

const router = Router();

/**
 * GET /api/metrics/prime-cost?date=YYYY-MM-DD
 * If date omitted, uses latest shift_date from daily_sales_v2.
 * Returns { daily: {...}, mtd: {...} }
 */
router.get("/api/metrics/prime-cost", async (req, res) => {
  try {
    const date = (req.query.date as string) || (await getLatestShiftDate());
    if (!date) return res.json({ ok: false, error: "no-shift-date" });

    const daily = await getPrimeCostForDate(date);
    const mtd = await getPrimeCostMTD(date);
    res.json({ ok: true, date, daily, mtd });
  } catch (e:any) {
    res.status(500).json({ ok:false, error: e?.message ?? "prime-cost-failed" });
  }
});

export default router;

Register route in server/index.ts (before any catch-alls):

import primeCostRouter from "./routes/primeCost.js";
app.use(primeCostRouter);

Agent guardrails

Do not rename existing tables/columns.

If your expenses table/columns differ, only edit the four constants at the top of primeCost.ts.

Keep this endpoint read-only; no writes.



---

Frontend — add a small card on the main dashboard

In the main page component (usually client/src/pages/Home.tsx or client/src/pages/index.tsx), add the card. If your file is named differently, insert this block where the top metrics cards live.

import { useEffect, useState } from "react";

type PCDaily = { sales:number; wages:number; fnb:number; primeCost:number; primePct:number|null; };
type PCMtd = { sales:number; wages:number; fnb:number; primeCost:number; primePct:number|null; };

export default function Home() {
  const [loading,setLoading] = useState(true);
  const [err,setErr] = useState<string>("");
  const [daily,setDaily] = useState<PCDaily|null>(null);
  const [mtd,setMtd] = useState<PCMtd|null>(null);
  const [date,setDate] = useState<string>("");

  useEffect(() => {
    (async () => {
      try {
        const r = await fetch("/api/metrics/prime-cost");
        const j = await r.json();
        if (!j.ok) { setErr(j.error||"failed"); setLoading(false); return; }
        setDate(j.date);
        setDaily(j.daily);
        setMtd(j.mtd);
      } catch(e:any) {
        setErr(e?.message||"failed");
      } finally { setLoading(false); }
    })();
  }, []);

  const pc = (v:number|null) => v==null ? "—" : `${v.toFixed(1)}%`;

  const color = (v:number|null) => {
    if (v==null) return "bg-slate-200 text-slate-700";
    if (v <= 55) return "bg-emerald-100 text-emerald-800";
    if (v <= 60) return "bg-amber-100 text-amber-800";
    return "bg-rose-100 text-rose-800";
  };

  return (
    <div className="p-4">
      {/* ...existing dashboard content... */}

      <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
        <div className="rounded-lg border p-4">
          <div className="text-sm text-slate-600">Prime Cost — Latest Shift</div>
          <div className="text-xs text-slate-500 mb-2">Shift date: {date || "—"}</div>
          {loading ? (
            <div className="text-slate-500 text-sm">Loading…</div>
          ) : err ? (
            <div className="text-rose-600 text-sm">{err}</div>
          ) : (
            <>
              <div className={`inline-block px-3 py-1 rounded ${color(daily?.primePct)}`}>
                {pc(daily?.primePct)}
              </div>
              <div className="mt-3 text-xs text-slate-600 space-y-1">
                <div>Sales: ฿{(daily?.sales||0).toLocaleString()}</div>
                <div>Wages: ฿{(daily?.wages||0).toLocaleString()}</div>
                <div>Food & Beverage: ฿{(daily?.fnb||0).toLocaleString()}</div>
              </div>
            </>
          )}
        </div>

        <div className="rounded-lg border p-4">
          <div className="text-sm text-slate-600">Prime Cost — MTD</div>
          {loading ? (
            <div className="text-slate-500 text-sm">Loading…</div>
          ) : err ? (
            <div className="text-rose-600 text-sm">{err}</div>
          ) : (
            <>
              <div className={`inline-block px-3 py-1 rounded ${color(mtd?.primePct)}`}>
                {pc(mtd?.primePct)}
              </div>
              <div className="mt-3 text-xs text-slate-600 space-y-1">
                <div>Sales: ฿{(mtd?.sales||0).toLocaleString()}</div>
                <div>Wages: ฿{(mtd?.wages||0).toLocaleString()}</div>
                <div>Food & Beverage: ฿{(mtd?.fnb||0).toLocaleString()}</div>
              </div>
            </>
          )}
        </div>
      </div>
    </div>
  );
}


---

QA checklist (agent must tick)

1. Pin constants in primeCost.ts to the actual table/column names from the probe queries.


2. Hit GET /api/metrics/prime-cost and confirm payload:

daily.sales equals daily_sales_v2.total_sales for the date

daily.wages equals daily_sales_v2.wages_total

daily.fnb equals the sum of Business Expense rows for that date where category is F&B

daily.primePct = (wages + fnb)/sales*100



3. Confirm MTD numbers match manual sums for the current month.


4. Load the dashboard main page and confirm the two cards render values and colour banding (≤55 green, 55–60 amber, >60 red).


5. No schema changes, no drops, no extra endpoints beyond /api/metrics/prime-cost.




---

Guardrails / do-not-do

Do not read F&B from Stock Purchases; only Business Expenses modal, as requested.

Do not “fix” any other routes or move cron jobs.

Do not rename or migrate any existing columns.

If columns differ from the defaults, only change the constants at the top of primeCost.ts.

